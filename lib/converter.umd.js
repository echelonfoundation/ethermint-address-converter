!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports,require("crypto-addr-codec"),require("bech32")):"function"==typeof define&&define.amd?define(["exports","crypto-addr-codec","bech32"],r):r((e||self).echelonAddressConverter={},e.cryptoAddrCodec,e.bech32)}(this,function(e,r,o){const d={decoder:e=>{const o=r.stripHexPrefix(e);if(!r.isValidChecksumAddress(e,null)&&o!==o.toLowerCase()&&o!==o.toUpperCase())throw Error("Invalid address checksum");return Buffer.from(r.stripHexPrefix(e),"hex")},encoder:e=>r.toChecksumAddress(e.toString("hex"),null),name:"ETH"};function n(e){return r=>o.encode(e,o.toWords(r))}const c=(e,r)=>{return{decoder:(d=r,e=>{const{prefix:r,words:n}=o.decode(e);if(r!==d)throw Error("Unrecognised address format");return Buffer.from(o.fromWords(n))}),encoder:n(r),name:e};var d},t=c("echelonvaloper","echelonvaloper"),s=c("echelon","echelon");e.ECH=s,e.ECHV=t,e.ETH=d,e.echelonToEth=e=>{let r=s.decoder(e);return d.encoder(r)},e.echelonvToEth=e=>{let r=t.decoder(e);return d.encoder(r)},e.ethToEchelon=e=>{let r=d.decoder(e);return s.encoder(r)},e.ethToEchelonv=e=>{let r=d.decoder(e);return t.encoder(r)}});
//# sourceMappingURL=converter.umd.js.map
